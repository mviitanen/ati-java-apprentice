\subsection{StringBuffer vs StringBuilder}
\textit{Compare and contrast StringBuffer and StringBuilder and when to use each}
StringBuffer and StringBuilder have identical APIs. The main difference between them is that a StringBuffer is thread-safe and StringBuilder is not.

StringBuffer is the older of the two and was created with synchronization so it could be used by several threads. In practice, it is hard to find a real use case for that. In theory, StringBuilder, that is not thread-safe, is faster because it doesn't have to worry about concurrency.

\subsubsection{Concurrent Writes}
I wrote a simple program that Creates two threads that write into a StringBuilder and a StringBuffer 10 times. See appendix C on page \pageref{App:AppendixC}.

The thread writes into the buffer, then into the builder, and then sleeps for 10ms. In the end it prints out the contents of the StringBuilder and the StringBuffer:
\begin{lstlisting}
Buffer	Builder
0:0     1:0
1:0     0:0
0:1     0:1
1:1     1:1
0:2     ????0:2
1:2     1:3
1:3     0:3
0:3     1:4
1:4     0:4
0:4     1:5
1:5     0:5
0:5     1:6
1:6     0:6
0:6     1:7
1:7     0:7
0:7     1:8
1:8     0:8
0:8     1:9
1:9     0:9
0:9     
\end{lstlisting}

The contents of the StringBuilder and StringBuffer are different. Not only is the order different but the StringBuilder seems to be missing a line. Thread 1, iteration 2 is missing in the StringBuilder output. Instead there are non-printing characters (shown as '?').

Looking at the bytes in the StringBuilder shows the issue.

Each line consists of four characters; the thread name (really a number from 0 to 9), a colon, and the counter value (from 0 to 9), and a new line character, like this:
\begin{lstlisting}
31 3a 30 0a    1:0.
\end{lstlisting}
The StringBuilder contains exactly four bytes of 0's, though, starting in position 10 (second line in the following listing)
\begin{lstlisting}
0000000: 313a 300a 303a 300a 303a 310a 313a 310a
0000010: 0000 0000 303a 320a 313a 330a 303a 330a
0000020: 313a 340a 303a 340a 313a 350a 303a 350a
0000030: 313a 360a 303a 360a 313a 370a 303a 370a
0000040: 313a 380a 303a 380a 313a 390a 303a 390a
\end{lstlisting}

It looks like the two threads collided. Thread 1 reserved 4 bytes in the StringBuilder, but thread 2 wrote its output. This clearly shows how StringBuilder is not thread safe.

\subsubsection{Comparison Test}
I compared appends to a StringBuffer and a StringBuilder to see which one is faster. I used different lengths of strings and different number of additions. See appendix D on page \pageref{App:AppendixD}.

I appended strings of 1, 5, 10, 25, and 50 characters long into a StringBuffer or a StringBuilder. I appended from 1,000,000 to 10,000,000 strings per run, in increments of 1,000,000 strings.

In the graph below, we can see that as for both the StringBuffer and the StringBuilder, when the size of the string to append increased, the time increased also. Even greater was the time increase as the number of additions grew. In those aspects both the StringBuffer and the StringBuilder behaved similarly.

Suprisingly, appending into a StringBuilder was not always faster than into a StringBuffer. In the graph, the blue plane is the data of appending into a StringBuffer. The red dots show when appending into a StringBuilder was slower. Although the difference is not great, there is no clear pattern of why the StringBuilder was slower sometimes.

\pgfplotstableread{buffer.txt}{\plotdata}
\begin{figure}[H]\centering
\begin{framed}
\begin{tikzpicture}
  \begin{axis}[view/h=40, grid=both, xlabel={String Size}, ylabel={Additions ($10^7$)}, zlabel={Time (ms)}, ylabel shift=-15pt, xlabel shift=-10pt, zlabel shift=-6pt,ytick scale label code/.code={}]
\addplot3[surf, opacity=0.8, colormap=
    {blackblue}{color=(blue) color=(blue)}] file {buffer.txt};    
    \addplot3[red!80,mark=*,
mark options={fill=red!80!red},
only marks,mark size=1pt] file {builder2.txt};    
  \end{axis}
\end{tikzpicture}
\end{framed}
\label{fig:stringbuildervsStringBuffer}
\end{figure}
